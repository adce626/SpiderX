"""
Vulnerability Parameter Detection Module
كاشف المعاملات المحتملة للثغرات الأمنية

Advanced vulnerability detection for URL parameters - LEGENDARY FEATURE
"""

import re
from typing import Dict, List, Set, Tuple
from collections import defaultdict
from urllib.parse import urlparse, parse_qs


class VulnerabilityDetector:
    """Advanced vulnerability detection for parameters"""
    
    def __init__(self):
        # Vulnerability patterns with scoring
        self.vuln_patterns = {
            'xss_critical': {
                'patterns': ['search', 'query', 'q', 'keyword', 'term', 'input', 'data', 'content', 'msg', 'message', 'comment', 'text'],
                'score': 10,
                'description': 'High XSS potential parameters'
            },
            'sqli_critical': {
                'patterns': ['id', 'uid', 'user_id', 'product_id', 'item_id', 'post_id', 'page_id', 'category_id', 'order_id'],
                'score': 10,
                'description': 'High SQL injection potential'
            },
            'lfi_critical': {
                'patterns': ['file', 'path', 'page', 'include', 'template', 'view', 'load', 'read', 'doc', 'document'],
                'score': 9,
                'description': 'Local file inclusion potential'
            },
            'redirect_critical': {
                'patterns': ['url', 'redirect', 'next', 'return', 'continue', 'goto', 'target', 'dest', 'link'],
                'score': 8,
                'description': 'Open redirect potential'
            },
            'api_critical': {
                'patterns': ['key', 'token', 'api_key', 'access_token', 'auth', 'secret', 'password', 'pass'],
                'score': 10,
                'description': 'API security parameters'
            },
            'debug_medium': {
                'patterns': ['debug', 'test', 'dev', 'admin', 'trace', 'verbose', 'log', 'error'],
                'score': 7,
                'description': 'Debug/admin parameters'
            },
            'idor_medium': {
                'patterns': ['user', 'account', 'profile', 'session', 'sess', 'userid', 'username'],
                'score': 8,
                'description': 'IDOR potential parameters'
            },
            'command_injection': {
                'patterns': ['cmd', 'command', 'exec', 'shell', 'system', 'run', 'execute'],
                'score': 10,
                'description': 'Command injection potential'
            }
        }
        
        # Parameter complexity patterns
        self.complexity_patterns = {
            'high_value': ['admin', 'auth', 'key', 'token', 'password', 'secret'],
            'medium_value': ['user', 'id', 'search', 'query', 'data'],
            'low_value': ['page', 'sort', 'limit', 'offset', 'lang']
        }
    
    def analyze_parameters(self, urls: List[str]) -> Dict:
        """Comprehensive parameter analysis"""
        all_params = set()
        param_frequency = defaultdict(int)
        param_sources = defaultdict(set)
        vulnerability_findings = defaultdict(list)
        
        for url in urls:
            try:
                parsed = urlparse(url)
                params = parse_qs(parsed.query)
                domain = parsed.netloc
                
                for param in params.keys():
                    all_params.add(param)
                    param_frequency[param] += 1
                    param_sources[param].add(domain)
                    
                    # Check for vulnerabilities
                    vulns = self._check_parameter_vulnerabilities(param)
                    for vuln in vulns:
                        vulnerability_findings[vuln['type']].append({
                            'parameter': param,
                            'url': url,
                            'domain': domain,
                            'score': vuln['score'],
                            'description': vuln['description']
                        })
            except Exception:
                continue
        
        return {
            'total_parameters': len(all_params),
            'parameter_frequency': dict(param_frequency),
            'parameter_sources': {k: list(v) for k, v in param_sources.items()},
            'vulnerability_findings': dict(vulnerability_findings),
            'high_risk_parameters': self._get_high_risk_parameters(vulnerability_findings),
            'complexity_analysis': self._analyze_complexity(all_params)
        }
    
    def _check_parameter_vulnerabilities(self, param: str) -> List[Dict]:
        """Check parameter for potential vulnerabilities"""
        vulnerabilities = []
        param_lower = param.lower()
        
        for vuln_type, config in self.vuln_patterns.items():
            for pattern in config['patterns']:
                if (pattern in param_lower or 
                    param_lower.startswith(pattern) or 
                    param_lower.endswith(pattern)):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'score': config['score'],
                        'description': config['description'],
                        'pattern_matched': pattern
                    })
                    break
        
        return vulnerabilities
    
    def _get_high_risk_parameters(self, vulnerability_findings: Dict) -> List[Dict]:
        """Get parameters with highest vulnerability scores"""
        high_risk = []
        
        for vuln_type, findings in vulnerability_findings.items():
            for finding in findings:
                if finding['score'] >= 8:  # High risk threshold
                    high_risk.append(finding)
        
        # Sort by score descending
        return sorted(high_risk, key=lambda x: x['score'], reverse=True)
    
    def _analyze_complexity(self, params: Set[str]) -> Dict:
        """Analyze parameter complexity for fuzzing priority"""
        complexity_scores = {}
        
        for param in params:
            score = 0
            param_lower = param.lower()
            
            # Length scoring
            if len(param) > 6:
                score += 2
            elif len(param) > 3:
                score += 1
            
            # Complexity patterns
            if '_' in param or '-' in param:
                score += 2
            if any(char.isdigit() for char in param):
                score += 1
            if param.endswith('_id') or param.endswith('Id'):
                score += 3
            
            # Value assessment
            if any(keyword in param_lower for keyword in self.complexity_patterns['high_value']):
                score += 5
            elif any(keyword in param_lower for keyword in self.complexity_patterns['medium_value']):
                score += 3
            elif any(keyword in param_lower for keyword in self.complexity_patterns['low_value']):
                score += 1
            
            complexity_scores[param] = score
        
        return complexity_scores
    
    def generate_vulnerability_report(self, analysis: Dict) -> str:
        """Generate detailed vulnerability report"""
        report = []
        report.append("🔍 VULNERABILITY ANALYSIS REPORT")
        report.append("=" * 50)
        report.append("")
        
        # Summary
        total_params = analysis['total_parameters']
        high_risk = len(analysis['high_risk_parameters'])
        report.append(f"📊 SUMMARY:")
        report.append(f"   Total Parameters: {total_params}")
        report.append(f"   High Risk Parameters: {high_risk}")
        report.append(f"   Risk Percentage: {(high_risk/total_params*100):.1f}%" if total_params > 0 else "   Risk Percentage: 0%")
        report.append("")
        
        # High Risk Parameters
        if analysis['high_risk_parameters']:
            report.append("🚨 HIGH RISK PARAMETERS:")
            for finding in analysis['high_risk_parameters'][:10]:  # Top 10
                report.append(f"   • {finding['parameter']} (Score: {finding['score']}/10)")
                report.append(f"     Risk: {finding['description']}")
                report.append(f"     Domain: {finding['domain']}")
                report.append("")
        
        # Vulnerability Categories
        vuln_findings = analysis['vulnerability_findings']
        if vuln_findings:
            report.append("🛡️ VULNERABILITY CATEGORIES:")
            for vuln_type, findings in vuln_findings.items():
                count = len(findings)
                report.append(f"   • {vuln_type.replace('_', ' ').title()}: {count} parameters")
            report.append("")
        
        # Top Parameters by Frequency
        freq = analysis['parameter_frequency']
        if freq:
            report.append("📈 MOST FREQUENT PARAMETERS:")
            sorted_params = sorted(freq.items(), key=lambda x: x[1], reverse=True)
            for param, count in sorted_params[:10]:
                report.append(f"   • {param}: {count} occurrences")
            report.append("")
        
        return "\n".join(report)


class SmartParameterRanker:
    """Smart parameter ranking for testing priority - LEGENDARY FEATURE"""
    
    def __init__(self):
        self.ranking_weights = {
            'vulnerability_score': 0.4,
            'frequency': 0.2,
            'complexity': 0.2,
            'domain_spread': 0.2
        }
    
    def rank_parameters(self, analysis: Dict) -> List[Tuple[str, float]]:
        """Rank parameters by testing priority"""
        param_scores = {}
        
        # Get all unique parameters
        all_params = set(analysis['parameter_frequency'].keys())
        total_frequency = sum(analysis['parameter_frequency'].values())
        total_domains = len(set().union(*analysis['parameter_sources'].values()))
        
        for param in all_params:
            score = 0.0
            
            # Vulnerability score
            vuln_score = self._get_vulnerability_score(param, analysis['vulnerability_findings'])
            score += vuln_score * self.ranking_weights['vulnerability_score']
            
            # Frequency score (normalized)
            freq = analysis['parameter_frequency'].get(param, 0)
            freq_score = (freq / total_frequency) * 10 if total_frequency > 0 else 0
            score += freq_score * self.ranking_weights['frequency']
            
            # Complexity score
            complexity = analysis['complexity_analysis'].get(param, 0)
            complexity_score = min(complexity / 10, 1.0) * 10  # Normalize to 0-10
            score += complexity_score * self.ranking_weights['complexity']
            
            # Domain spread score
            domain_count = len(analysis['parameter_sources'].get(param, []))
            domain_score = (domain_count / total_domains) * 10 if total_domains > 0 else 0
            score += domain_score * self.ranking_weights['domain_spread']
            
            param_scores[param] = score
        
        # Sort by score descending
        return sorted(param_scores.items(), key=lambda x: x[1], reverse=True)
    
    def _get_vulnerability_score(self, param: str, vulnerability_findings: Dict) -> float:
        """Get vulnerability score for a parameter"""
        max_score = 0
        
        for vuln_type, findings in vulnerability_findings.items():
            for finding in findings:
                if finding['parameter'] == param:
                    max_score = max(max_score, finding['score'])
        
        return max_score